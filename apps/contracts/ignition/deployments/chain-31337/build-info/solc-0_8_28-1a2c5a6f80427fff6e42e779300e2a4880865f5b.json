{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-1a2c5a6f80427fff6e42e779300e2a4880865f5b",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EscrowFactory.sol": "project/contracts/EscrowFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/Escrow.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.28;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\n/**\r\n * @title Escrow\r\n * @author Dispute-Minimized Upgrade\r\n * @notice A trustless escrow contract with deadline-based auto-resolution.\r\n * @dev Escrow outcomes are deterministically derivable from on-chain state and time.\r\n *      No escrow remains indefinitely locked due to user inactivity.\r\n */\r\ncontract Escrow is ReentrancyGuard {\r\n    using Address for address payable;\r\n\r\n    // --- Enums ---\r\n\r\n    /// @notice Monotonic, irreversible state machine\r\n    enum State {\r\n        AWAITING_PAYMENT,  // 0: Contract created, awaiting buyer deposit\r\n        FUNDED,            // 1: Buyer deposited, awaiting seller delivery\r\n        DELIVERED,         // 2: Seller marked delivery, buyer review period active\r\n        COMPLETE,          // 3: Funds released to seller (terminal)\r\n        REFUNDED,          // 4: Funds returned to buyer (terminal)\r\n        DISPUTED           // 5: Dispute raised, awaiting arbiter resolution\r\n    }\r\n\r\n    // --- State Variables ---\r\n\r\n    address public immutable buyer;\r\n    address public immutable seller;\r\n    address public immutable arbiter;\r\n    uint256 public immutable amount;\r\n    \r\n    /// @notice Deadline by which seller must mark delivery (Unix timestamp)\r\n    uint256 public immutable deliveryDeadline;\r\n    \r\n    /// @notice Duration (seconds) buyer has to approve/dispute after delivery\r\n    uint256 public immutable reviewPeriod;\r\n\r\n    State public state;\r\n    \r\n    /// @notice Timestamp when seller marked delivery (0 if not yet delivered)\r\n    uint256 public deliveredAt;\r\n\r\n    // --- Events ---\r\n\r\n    event Deposited(address indexed buyer, uint256 amount);\r\n    event DeliveryMarked(address indexed seller, uint256 timestamp);\r\n    event DeliveryConfirmed(address indexed buyer);\r\n    event Refunded(address indexed caller, uint256 amount);\r\n    event AutoReleased(address indexed caller, uint256 amount);\r\n    event AutoRefunded(address indexed caller, uint256 amount);\r\n    event DisputeOpened(address indexed caller);\r\n    event DisputeResolved(address indexed arbiter, address winner, uint256 amount);\r\n\r\n    // --- Errors ---\r\n\r\n    error OnlyBuyer();\r\n    error OnlySeller();\r\n    error OnlyArbiter();\r\n    error OnlyBuyerOrSeller();\r\n    error InvalidState(State current, State expected);\r\n    error IncorrectAmount(uint256 sent, uint256 expected);\r\n    error DeliveryDeadlineNotPassed();\r\n    error DeliveryDeadlinePassed();\r\n    error ReviewPeriodNotEnded();\r\n    error ReviewPeriodEnded();\r\n    error NoArbiterSet();\r\n    error InvalidWinner();\r\n\r\n    // --- Modifiers ---\r\n\r\n    modifier onlyBuyer() {\r\n        if (msg.sender != buyer) revert OnlyBuyer();\r\n        _;\r\n    }\r\n\r\n    modifier onlySeller() {\r\n        if (msg.sender != seller) revert OnlySeller();\r\n        _;\r\n    }\r\n\r\n    modifier onlyArbiter() {\r\n        if (msg.sender != arbiter) revert OnlyArbiter();\r\n        _;\r\n    }\r\n\r\n    modifier inState(State _state) {\r\n        if (state != _state) revert InvalidState(state, _state);\r\n        _;\r\n    }\r\n\r\n    // --- Constructor ---\r\n\r\n    /**\r\n     * @notice Initializes the Escrow contract with deadline parameters.\r\n     * @param _buyer The address of the buyer (payer).\r\n     * @param _seller The address of the seller (payee).\r\n     * @param _arbiter The address of the arbiter.\r\n     * @param _amount The amount of ETH to be escrowed.\r\n     * @param _deliveryDeadline Unix timestamp by which seller must mark delivery.\r\n     * @param _reviewPeriod Duration in seconds for buyer review after delivery.\r\n     */\r\n    constructor(\r\n        address _buyer,\r\n        address _seller,\r\n        address _arbiter,\r\n        uint256 _amount,\r\n        uint256 _deliveryDeadline,\r\n        uint256 _reviewPeriod\r\n    ) payable {\r\n        require(_buyer != address(0), \"Invalid buyer\");\r\n        require(_seller != address(0), \"Invalid seller\");\r\n        require(_amount > 0, \"Amount must be > 0\");\r\n        require(_deliveryDeadline > block.timestamp, \"Deadline must be future\");\r\n        require(_reviewPeriod > 0, \"Review period must be > 0\");\r\n\r\n        buyer = _buyer;\r\n        seller = _seller;\r\n        arbiter = _arbiter;\r\n        amount = _amount;\r\n        deliveryDeadline = _deliveryDeadline;\r\n        reviewPeriod = _reviewPeriod;\r\n\r\n        if (msg.value > 0) {\r\n            if (msg.value != _amount) revert IncorrectAmount(msg.value, _amount);\r\n            state = State.FUNDED;\r\n            emit Deposited(_buyer, msg.value);\r\n        } else {\r\n            state = State.AWAITING_PAYMENT;\r\n        }\r\n    }\r\n\r\n    // --- Core Functions ---\r\n\r\n    /**\r\n     * @notice Buyer deposits the funds into the escrow.\r\n     */\r\n    function deposit() external payable onlyBuyer inState(State.AWAITING_PAYMENT) {\r\n        if (msg.value != amount) revert IncorrectAmount(msg.value, amount);\r\n        state = State.FUNDED;\r\n        emit Deposited(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Seller marks the order as delivered. Starts the buyer review period.\r\n     * @dev Must be called before deliveryDeadline.\r\n     */\r\n    function markDelivered() external onlySeller inState(State.FUNDED) {\r\n        if (block.timestamp > deliveryDeadline) revert DeliveryDeadlinePassed();\r\n        \r\n        state = State.DELIVERED;\r\n        deliveredAt = block.timestamp;\r\n        emit DeliveryMarked(msg.sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Buyer confirms delivery and releases funds to seller.\r\n     * @dev Only callable during review period.\r\n     */\r\n    function confirmDelivery() external nonReentrant onlyBuyer inState(State.DELIVERED) {\r\n        if (block.timestamp > deliveredAt + reviewPeriod) revert ReviewPeriodEnded();\r\n        \r\n        state = State.COMPLETE;\r\n        payable(seller).sendValue(address(this).balance);\r\n        emit DeliveryConfirmed(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Seller voluntarily refunds the buyer.\r\n     */\r\n    function refund() external nonReentrant onlySeller inState(State.FUNDED) {\r\n        state = State.REFUNDED;\r\n        uint256 balance = address(this).balance;\r\n        payable(buyer).sendValue(balance);\r\n        emit Refunded(msg.sender, balance);\r\n    }\r\n\r\n    // --- Timeout Functions ---\r\n\r\n    /**\r\n     * @notice Auto-release funds to seller if buyer didn't respond within review period.\r\n     * @dev Can be called by anyone after review period ends.\r\n     */\r\n    function claimByTimeout() external nonReentrant inState(State.DELIVERED) {\r\n        if (block.timestamp <= deliveredAt + reviewPeriod) revert ReviewPeriodNotEnded();\r\n        \r\n        state = State.COMPLETE;\r\n        uint256 balance = address(this).balance;\r\n        payable(seller).sendValue(balance);\r\n        emit AutoReleased(msg.sender, balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Buyer claims refund if seller didn't deliver before deadline.\r\n     * @dev Only callable after deliveryDeadline has passed without delivery.\r\n     */\r\n    function claimRefundByTimeout() external nonReentrant onlyBuyer inState(State.FUNDED) {\r\n        if (block.timestamp <= deliveryDeadline) revert DeliveryDeadlineNotPassed();\r\n        \r\n        state = State.REFUNDED;\r\n        uint256 balance = address(this).balance;\r\n        payable(buyer).sendValue(balance);\r\n        emit AutoRefunded(msg.sender, balance);\r\n    }\r\n\r\n    // --- Dispute Functions ---\r\n\r\n    /**\r\n     * @notice Raise a dispute during the review period.\r\n     * @dev Only buyer or seller can dispute. Arbiter must be set.\r\n     */\r\n    function dispute() external inState(State.DELIVERED) {\r\n        if (msg.sender != buyer && msg.sender != seller) revert OnlyBuyerOrSeller();\r\n        if (arbiter == address(0)) revert NoArbiterSet();\r\n        if (block.timestamp > deliveredAt + reviewPeriod) revert ReviewPeriodEnded();\r\n\r\n        state = State.DISPUTED;\r\n        emit DisputeOpened(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Arbiter resolves a dispute by sending funds to the winner.\r\n     * @param winner The address to receive the funds (must be buyer or seller).\r\n     */\r\n    function resolveDispute(address winner) external nonReentrant onlyArbiter inState(State.DISPUTED) {\r\n        if (winner != buyer && winner != seller) revert InvalidWinner();\r\n        \r\n        uint256 balance = address(this).balance;\r\n        \r\n        if (winner == buyer) {\r\n            state = State.REFUNDED;\r\n        } else {\r\n            state = State.COMPLETE;\r\n        }\r\n\r\n        payable(winner).sendValue(balance);\r\n        emit DisputeResolved(msg.sender, winner, balance);\r\n    }\r\n\r\n    // --- View Functions ---\r\n\r\n    /**\r\n     * @notice Returns the deadline for buyer to respond after delivery.\r\n     * @return Unix timestamp, or 0 if not yet delivered.\r\n     */\r\n    function reviewDeadline() external view returns (uint256) {\r\n        if (deliveredAt == 0) return 0;\r\n        return deliveredAt + reviewPeriod;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the escrow can be auto-released to seller.\r\n     */\r\n    function canClaimByTimeout() external view returns (bool) {\r\n        return state == State.DELIVERED && block.timestamp > deliveredAt + reviewPeriod;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the buyer can claim refund due to seller timeout.\r\n     */\r\n    function canClaimRefundByTimeout() external view returns (bool) {\r\n        return state == State.FUNDED && block.timestamp > deliveryDeadline;\r\n    }\r\n}\r\n"
      },
      "project/contracts/EscrowFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.28;\r\n\r\nimport \"./Escrow.sol\";\r\n\r\n/**\r\n * @title EscrowFactory\r\n * @notice Factory contract for deploying dispute-minimized Escrow instances.\r\n */\r\ncontract EscrowFactory {\r\n    event EscrowCreated(\r\n        address indexed escrowAddress, \r\n        address indexed buyer, \r\n        address indexed seller, \r\n        address arbiter, \r\n        uint256 amount,\r\n        uint256 deliveryDeadline,\r\n        uint256 reviewPeriod\r\n    );\r\n\r\n    /**\r\n     * @notice Deploys a new Escrow contract with deadline parameters.\r\n     * @param _seller The address of the seller.\r\n     * @param _arbiter The address of the arbiter (can be address(0) to disable disputes).\r\n     * @param _deliveryDeadline Unix timestamp by which seller must mark delivery.\r\n     * @param _reviewPeriod Duration in seconds for buyer review after delivery.\r\n     * @return The address of the newly deployed Escrow contract.\r\n     */\r\n    function createEscrow(\r\n        address _seller, \r\n        address _arbiter,\r\n        uint256 _deliveryDeadline,\r\n        uint256 _reviewPeriod\r\n    ) external payable returns (address) {\r\n        Escrow newEscrow = new Escrow{value: msg.value}(\r\n            msg.sender,\r\n            _seller,\r\n            _arbiter,\r\n            msg.value,\r\n            _deliveryDeadline,\r\n            _reviewPeriod\r\n        );\r\n\r\n        emit EscrowCreated(\r\n            address(newEscrow), \r\n            msg.sender, \r\n            _seller, \r\n            _arbiter, \r\n            msg.value,\r\n            _deliveryDeadline,\r\n            _reviewPeriod\r\n        );\r\n\r\n        return address(newEscrow);\r\n    }\r\n}\r\n"
      }
    }
  }
}